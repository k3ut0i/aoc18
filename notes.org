* Notes
** Day 03
If iterating over an array of more than one dimension, *row-major-index* and *row-major-aref* may help by iterating over just one variable.

#+BEGIN_SRC lisp
  (defparameter a (make-array (list 10 10)))

  (dotimes (x 10)
    (dotimes (y 10)
      (setf (aref a x y) (random 10))))

  (loop :for i :below (array-total-size a)
       :maximizing (row-major-aref a i))
#+END_SRC

#+RESULTS:
: 9

** Day 04
get-max and other related functions could be just inlined, if I used reduce.
If iterating for a single value, just use reduce or find or something similar. Do go all the way to loop for simple iterations.

** Day 05
I should've used char-equal to compare characters ignoring case. That would've improved flow of in both trigger-poly and remove-if(part2).
#+BEGIN_SRC lisp
  (char-equal #\A #\a)
#+END_SRC

#+RESULTS:
: T

** Day 09
For part 1 the using a list as a circle buffer sufficed. But most expensive operations in this problem seem to be insert and delete in the circle buffer. 
*** Part 1
First attempt stats
#+BEGIN_EXAMPLE
Evaluation took:
  5.658 seconds of real time
  5.662797 seconds of total run time (5.442621 user, 0.220176 system)
  [ Run times consist of 0.703 seconds GC time, and 4.960 seconds non-GC time. ]
  100.09% CPU
  9,596,470,454 processor cycles
  1,066,784,032 bytes consed
#+END_EXAMPLE

Worse with a lot of rplacd and setf cdrs. This implementation still exists as a reference to using destructive list operations. I haven't used them before. 
#+BEGIN_EXAMPLE
Evaluation took:
  24.966 seconds of real time
  24.965778 seconds of total run time (24.965647 user, 0.000131 system)
  100.00% CPU
  42,344,029,675 processor cycles
  3,276,800 bytes consed
#+END_EXAMPLE
I think last function was the problem. Must learn profiling.
So there is a reason when people say don't optimize blindly without looking for bottle necks.
*** Part 2.
I have tried implementing this in *c* using circular doubly linked lists. It's a bit buggy, but runtime is awesome. Keep in mind the above lisp runtimes are for _71522_ Not _7152200_ given below.
#+BEGIN_EXAMPLE
./day09_02 446 7152200  0.53s user 0.15s system 99% cpu 0.682 total
#+END_EXAMPLE
[2018-12-11 Tue] My c solution for 71522 steps(and all the other examples) works perfectly. But for 7152200, answer just returned 0. After printing all the scores I've noticed that they were negative. This was my first case of integer overflow and wrap around. Using *long long* instead of int to store my scores solved the problem.

#+BEGIN_EXAMPLE
Maxscore: 3277920293
./day09_02 446 7152200  0.58s user 0.09s system 99% cpu 0.674 total
#+END_EXAMPLE

** Day 11

For a given size *s* and Grid size *S*. The number of calculations for finding maximum power withing a square of size *s* is (S - s)(S - s) (s*s -1).
Looking at the distribution of this as s changes we have
#+BEGIN_SRC R :var name="day11-cals.jpeg" :results file
    jpeg(filename=name,
	 width=640, height=480, units="px", pointsize=12,
	 quality=75,
	 bg="white", res=NA)
    size <- seq(1, 300)
    cals <- (300 - size)^2 * (size^2 - 1)
    barplot(cals, xlab="Power square size", ylab="Number of calculations",
	    main="Without optimization")
    name
#+END_SRC

#+RESULTS:
[[file:day11-cals.jpeg]]

This implementation runs for tens of minutes without reaching size 100, so it will likely run for more than an hour.

Given that there are no more than 300*300 elements in the grid, there are a lot of redundant calculations taking place. For any give power square size *s*, the calculations are always sequential additions. So if we accumulate the sum of all previous rows in each cell of the grid, the sum of a give power square is the sum of row-sums, row-sums are the difference b/w the last cell and cell-before first. so we can cut down the number of calculations to (S-s)^2 * (2*s - 1), an order less.

#+BEGIN_SRC R :results file :var fname="day11-calls-best.jpeg"
  jpeg(filename=fname,
       width=640, height=480, units="px", pointsize=12,
       quality=75,
       bg="white", res=NA)
  size <- seq(1, 300)
  cals <- (300 - size)^2 * (2*size - 1)
  barplot(cals, xlab="Power square size", ylab="Number of calculations",
	  main="Using accumulations to reduce per square cals from O(n^2) to O(n)")
  fname
#+END_SRC

#+RESULTS:
[[file:day11-calls-best.jpeg]]

The run time for this implementation is
#+BEGIN_EXAMPLE
  CL-USER> (time (part2 1309))
  Evaluation took:
    50.156 seconds of real time
    50.162501 seconds of total run time (50.102278 user, 0.060223 system)
    [ Run times consist of 0.251 seconds GC time, and 49.912 seconds non-GC time. ]
    100.01% CPU
    85,066,931,941 processor cycles
    1,897,395,792 bytes consed  
  108
  (233 271)
  13
#+END_EXAMPLE
